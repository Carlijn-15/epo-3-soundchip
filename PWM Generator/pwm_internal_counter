library IEEE;
use IEEE.std_logic_1164.ALL;

entity pwm_clk_cnt is
  port(clk, reset : in  std_logic;
       pwm_count : out std_logic_vector(6 downto 0));
end pwm_clk_cnt;

-- This entity is generating a counter within the pwm_controller.
-- That means that every clock from the internal pwm_controller we add 1 to it.
-- If it reached the max value, then be 0.
-- 2^15 = 32768, because that the max N. 

-- There are 133 rising edges within 1 pwm clock cycle. Thus max count is 133. 
-- We need this counter only when pwm is high, thus the period needed is 
-- (1/2)(1/~190kHz): ~62 counts. We somehow have to scale down the amount of 
-- levels in the duty count to 6 bits only => 2^6 = 64.

library IEEE;
use IEEE.std_logic_1164.ALL;
use IEEE.numeric_std.ALL;

architecture behaviour of pwm_clk_cnt is

  signal count : std_logic_vector(6 downto 0);

begin

  process(clk)
  begin

    if(reset = '0') then

      if(clk'event and clk = '1') then

        count <= std_logic_vector(unsigned(count) + (to_unsigned(1, 7)));

        if(to_integer(unsigned(count)) < 63) then

          pwm_count <= count;

        else

          pwm_count <= std_logic_vector(to_unsigned(0, 7));

        end if;
      end if;
    else

      count <= std_logic_vector(to_unsigned(0, 7));

    end if;

  end process;

end behaviour;
